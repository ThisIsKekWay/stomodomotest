# Задание

Таблица: Receptions (ID int NOT NULL, ID_Patients int NOT NULL, ID_Doctors int NOT NULL, StartDateTime datetime NOT NULL)

1)      Определить сколько приемов (всех пациентов) было в КАЖДУЮ дату 2015 года (для вывода информации на график)
2)      Для каждого пациента выбрать врача из последнего приема (по дате). Предложить несколько вариантов решения и сравнить, в каких ситуациях возвращаемые данные будут различаться


## 1. Данные для графика.

Для этой задачи можно использовать SQL-запрос с группировкой по дате. Предполагается, что StartDateTime хранит дату и время приема.

~~~
SELECT 
    DATE(StartDateTime) AS ReceptionDate,
    COUNT(*) AS ReceptionCount
FROM 
    Receptions
WHERE 
    YEAR(StartDateTime) = 2015
GROUP BY 
    ReceptionDate
ORDER BY 
    ReceptionDate;
~~~

## 2. Последний врач.

### Вариант 1. Подзапрос.

~~~
SELECT 
    r1.ID_Patients,
    r1.ID_Doctors
FROM 
    Receptions r1
WHERE 
    r1.StartDateTime = (
        SELECT MAX(r2.StartDateTime)
        FROM Receptions r2
        WHERE r2.ID_Patients = r1.ID_Patients
    );
~~~

Этот запрос использует подзапрос для нахождения последнего приема каждого пациента. Он подходит для небольших наборов данных, но может быть менее эффективным для больших таблиц из-за вложенного подзапроса.

### Вариант 2. Оконные функции.

~~~
SELECT 
    ID_Patients,
    ID_Doctors
FROM (
    SELECT 
        ID_Patients,
        ID_Doctors,
        ROW_NUMBER() OVER (PARTITION BY ID_Patients ORDER BY StartDateTime DESC) AS rn
    FROM 
        Receptions
) AS subquery
WHERE 
    rn = 1;
~~~

Этот запрос использует оконную функцию ROW_NUMBER() для нумерации приемов каждого пациента по дате в порядке убывания. Затем выбираются только те записи, где rn = 1, что соответствует последнему приему.

Сравнение вариантов:
- Производительность: Оконные функции обычно более эффективны для больших наборов данных, так как они позволяют избежать вложенных подзапросов.
- Простота: Подзапросы могут быть проще для понимания и реализации в простых случаях.
- Совместимость: Оконные функции поддерживаются не всеми СУБД, поэтому подзапросы могут быть более универсальным решением.

Различные результаты могут возникнуть в обоих вариантах если у одного пациента есть два приема с одинаковой датой, а подзапрос может вернуть вообще все подобные записи. Оконная функция с ROW_NUMBER() вернет только одну запись, так как она присваивает уникальный номер каждой строке. Однако, если есть несколько записей с одинаковым StartDateTime, то выбор конкретной записи может зависеть от внутреннего порядка данных в таблице, который не определен.